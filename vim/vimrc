" ==================================================================
" To use it, copy it to
"     for Unix and OS/2:  ~/.vimrc
"  for MS-DOS and Win32:  $VIM\_vimrc
"
"  If you don't understand a setting in here, just type :h 'setting'.
" ==================================================================

" ------------------------------------------------------------------
" Starting
" ------------------------------------------------------------------

" Use Vim settings, rather than Vi settings (much better!).
" This must be first, because it changes other options as a side effect.
set nocompatible

" Second, init vim-pathogen
call pathogen#infect()


" Switch syntax highlighting on.
syntax on

" Enable file type detection, plugin and language-dependent indenting.
filetype plugin indent on

if has("gui_running")
    " color scheme define
    colorscheme night

    " guifont
    if has("win32")
        set guifont=Fixedsys\ Console:h11
    else
        set guifont=MiscFixed\ 11
    endif

    " Maximize window when enter vim
    if has("win32")
        autocmd GUIEnter * simalt ~x
    else
        " TODO: no way right now
    endif

else " if we are in terminal mode
    colorscheme darkdot
endif

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
\ if line("'\"") > 0 && line("'\"") <= line("$") |
\   exe "normal g`\"" |
\ endif

" C++11 syntax support
autocmd BufNewFile,BufRead *.h,*.hpp,*.hxx,*.cpp,*.cxx set syntax=cpp11

" ------------------------------------------------------------------
" Options
" ------------------------------------------------------------------

" Make backspace behave in a sane manner, allow backspacing over everything in insert mode.
set backspace=indent,eol,start

set autoindent
set smartindent

set shiftwidth=4 " set indent to 4 spaces
set tabstop=4 " set tabstop to 4 spaces
set expandtab " set expandtab on, the tab will be change to space automaticaly

set clipboard=unnamed,unnamedplus " use clipboard register '*'(unnamed) and '+'(unnamedplus) for all y, d, c, p ops

set guioptions+=b " Present the bottom scrollbar when the longest visible line exceen the window
set guioptions-=m " disable menu
set guioptions-=T " disable toolbar

set langmenu=none " always use English menu

set autoread " auto read same-file change

set showmatch " show matching paren, actually shows
set matchtime=0 " 0 second to show the matching paren ( much faster )
set number " Show LineNumber
set scrolloff=0 " minimal number of screen lines to keep above and below the cursor
set nowrap " I don't like wrap, cause in split window mode, it feel strange

set wildmenu " turn on wild menu, try typing :h and press <Tab>
set wildignore+=*.a,*.o
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
set wildignore+=.DS_Store,.git,.hg,.svn
set wildignore+=*~,*.swp,*.tmp

set ruler " show the cursor position all the time
set showcmd " display incomplete commands
set showmode " display edit mode
set cmdheight=1 " 1 screen lines to use for the command-line
set hid " allow to change buffer without saving
set shortmess=atIO " shortens messages to avoid 'press a key' prompt
set lazyredraw " do not redraw while executing macros (much faster)
set display+=lastline " for easy browse last line with wrap text

set showfulltag " show tag with function protype.

set hlsearch " highlight search
set incsearch " do incremental searching
set ignorecase " Set search/replace pattern to ignore case
set smartcase " Set smartcase mode on, If there is upper case character in the search patern, the 'ignorecase' option will be override.

set history=50 " keep 50 lines of command line history
set updatetime=1000 " default = 4000
set nobackup " make no backup file and leave it around
set noswapfile " no swap file

set statusline=[%F]%h%w%r%m%=[%{strlen(&ft)?&ft:'none'},%{(&fenc==\"\"?&enc:&fenc)},%{&fileformat}][Line:%l/%L,Column:%c][%p%%]
set laststatus=2

set whichwrap=b,s,<,>,[,]
set formatoptions=mB

" auto detect file formats
set fileformats=unix,dos,mac

set encoding=utf-8
" auto detect file encodings
set fileencodings=ucs-bom,utf-8,chinese,japanese

set complete=.,w,b,u,i " default is '.,w,b,u,t,i', tags match is not from the word start, disable it
set completeopt=menu

set nf= " increase/decrease number format to decimal (default is octal)
set ve=block " In Visual Block Mode, cursor can be positioned where there is no actual character
set mouse=a " use mouse
set nomousehide " do not hide mouse

set diffopt=filler,vertical,foldcolumn:1


" ------------------------------------------------------------------
" Functions
" ------------------------------------------------------------------

" used by alias definition
func EatChar(pat)
   let c = nr2char(getchar(0))
   return (c =~ a:pat) ? '' : c
endf

" number every line
func LineIt()
    exe "s/^/".line(".")."/"
endf

" reverse all lines
func ReverseIt()
    exe "g/^/m0"
endf

" toggle fold state between closed and opened.
func ToggleFold()
    if foldlevel('.') == 0
        "normal! l
    else
        if foldclosed('.') < 0
            . foldclose
        else
            . foldopen
        endif
    endif
    " Clear status line
    echo
endf

" show current highlight group
func SyntaxItem()
  echo synIDattr(synID(line("."), col("."), 1), "name")
endf

" clearcase diff with current
func CtDiff()
    let f = system("cleartool ls -short " . fnamemodify(bufname('%'), ':p'))
    echo 'Current version (right): ' . f
    call inputsave()
    let v = input("Enter a version (default:LATEST) to diff (left): ")
    call inputrestore()
    let leftv = "LATEST"
    if !empty(v)
        let leftv = v
    endif
    let f = substitute(f, '/\w\+\n$', "/" . leftv, "")
    exe "diffsplit " . f
endf

" build from current dir
func Build()
    exe "wa"
    exe "cd %:h"
    exe "make"
    silent exe "cw"
    silent exe "cc"
endf

" toggle window size
func ToggleWinSize(vert)
    if a:vert
        if winwidth(0) < 50
            exe "vertical res" . winwidth(0)*2
        else
            exe "vertical res" . winwidth(0)/2
        endif
    else
        if winheight(0) < 40
            exe "res" . winheight(0)*2
        else
            exe "res" . winheight(0)/2
        endif
    endif
endf

" AutoClose, could be overruled
func AutoCloseOn()
    inoremap ( ()<ESC>:let leavechar=")"<CR>i
    inoremap { {}<ESC>:let leavechar="}"<CR>i
    inoremap [ []<ESC>:let leavechar="]"<CR>i
    inoremap < <><ESC>:let leavechar=">"<CR>i
    inoremap " ""<ESC>:let leavechar="\""<CR>i
    inoremap ' ''<ESC>:let leavechar="'"<CR>i
endf

func AutoCloseOff()
    iunmap (
    iunmap {
    iunmap [
    iunmap <
    iunmap "
    iunmap '
endf

call AutoCloseOn()
" get out
inoremap <unique> <C-j> <ESC>:exec "normal f" . leavechar<CR>a

" ------------------------------------------------------------------
" Mappings
" ------------------------------------------------------------------

" wean yourself off the arrow keys!
noremap <unique> <Up> <nop>
noremap <unique> <Down> <nop>
noremap <unique> <Left> <nop>
noremap <unique> <Right> <nop>

" move quickly
noremap <unique> <SPACE> 20j
noremap <unique> <BS> 20k

" win-like select all
nnoremap <unique> <LEADER>a ggvG$

" Yanking
nnoremap Y y$

" Edit another file in the same directory as the current file
if has("unix")
    noremap <unique> <Leader>e :e <C-R>=expand("%:p:h") . "/" <CR>
else
    noremap <unique> <Leader>e :e <C-R>=expand("%:p:h") . "\\" <CR>
endif

" switch window
noremap <unique> <silent> <LEADER>w <C-w>p
" switch buffer
noremap <unique> <silent> <LEADER><TAB> :b#<CR>
noremap <unique> <silent> <C-j> :bn<CR>
noremap <unique> <silent> <C-k> :bp<CR>

" swap with the next word
noremap <unique> <silent> <LEADER>sw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o>

" Enhance '<' '>' , do not need to reselect the block after shift it.
vnoremap <unique> < <gv
vnoremap <unique> > >gv

" turn off diff and set nowrap back (should op on to be quited window)
noremap <unique> <silent> <LEADER>d :diffoff!<CR>:bd<CR>:set nowrap<CR>

" easy search tags
noremap <unique> <silent> <LEADER>] g<C-]>

noremap <unique> <silent> <LEADER>f :call ToggleFold()<CR>

noremap <unique> <F9> :call Build()<CR>

" ------------------------------------------------------------------
" Highlights
" ------------------------------------------------------------------

hi DiffAdd ctermfg=black ctermbg=green guifg=black guibg=green
hi DiffDelete ctermfg=gray ctermbg=black guifg=gray guibg=black
hi DiffChange ctermfg=black ctermbg=yellow guifg=black guibg=yellow
hi DiffText ctermfg=black ctermbg=red guifg=black guibg=red

hi Folded ctermfg=gray guibg=gray
"hi FoldColumn ctermfg=gray guibg=gray

" highlight trailing spaces
hi ExtraWhitespace ctermbg=red guibg=red
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/


" ------------------------------------------------------------------
" Commands
" ------------------------------------------------------------------

" clearcase
command CO exe '!cleartool co -nc -unr ' . fnamemodify(bufname('%'), ':p')
command CI exe '!cleartool ci -nc ' . fnamemodify(bufname('%'), ':p')
command UC exe '!cleartool unco -rm ' . fnamemodify(bufname('%'), ':p')
command SCP exe '!scp ' . fnamemodify(bufname('%'), ':h') . '/.libs/*.so root@desthost:/home'
command DIFF call CtDiff()


" ------------------------------------------------------------------
" Plugins
" ------------------------------------------------------------------

" supertab
let tagfiles = tagfiles()
if !empty(tagfiles)
    " default is <c-p>
    let g:SuperTabDefaultCompletionType = "context"
endif

" nerdtree
noremap <unique> <silent> <F4> :NERDTreeToggle<CR>
noremap <unique> <silent> <LEADER>nf :NERDTreeFind<CR>
let NERDTreeIgnore = ['\.a[[file]]', '\.o[[file]]', '\.so[[file]]', '\.lo[[file]]', '\.la[[file]]', '\.pyc[[file]]', '\.d[[file]]']
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 0
hi def link NERDTreeRO Normal

" tagbar
noremap <unique> <silent> <F5> :TagbarToggle<CR>

" ctrlp
noremap <unique> <silent> <F6> :CtrlP<CR>
noremap <unique> <silent> <F8> :CtrlPBuffer<CR>
let g:ctrlp_by_filename = 1
let g:ctrlp_max_height = 20
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
    \ 'file': '\v\.(exe|dll|a|o|so|lo|la|pyc|d)$',
    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS' }
"   \ 'file': '\v(\.cpp|\.h|\.hh|\.cxx)@<!$'

" quickhl
nmap <unique> <silent> <LEADER>h <Plug>(quickhl-toggle)
nnoremap <unique> <silent> <LEADER>l ml:execute 'match Search /\%'.line('.').'l/'<CR>
nmap <unique> <silent> <C-h> :match<CR>:nohlsearch<CR><Plug>(quickhl-reset)

" sketch
noremap <unique> <F7> :call ToggleSketch()<CR>

" omnicppcomplete (need ctags DB)
let OmniCpp_ShowPrototypeInAbbr = 1
let OmniCpp_DefaultNamespaces = ["std"]

" gtags (need gtags DB)
noremap <unique> <LEADER>gt :Gtags<SPACE>
noremap <unique> <silent> <LEADER>gd :Gtags<CR><CR>
noremap <unique> <silent> <LEADER>gg :Gtags -g<CR><CR>
noremap <unique> <silent> <LEADER>gr :Gtags -r<CR><CR>

" plugin windows mapping, see help xterm-cursor-keys etc.
if has("gui_running")
    autocmd BufNewFile NERD_tree_1
    \ map <unique> <buffer> <silent> <ESC> <C-w>p<F4>|
    \ noremap <buffer> <silent> <SPACE> :call ToggleWinSize(1)<CR>0

    autocmd BufNewFile __Tagbar__
    \ map <unique> <buffer> <silent> <ESC> <C-w>p<F5>|
    \ noremap <buffer> <silent> <LEADER><SPACE> :call ToggleWinSize(1)<CR>0

    autocmd BufReadPost quickfix
    \ map <buffer> <silent> <ESC> <C-w>p:ccl<CR>|
    \ noremap <buffer> <silent> <SPACE> :call ToggleWinSize(0)<CR>
else
    autocmd BufNewFile NERD_tree_1
    \ map <unique> <buffer> <silent> <LEADER><ESC> <C-w>p<F4>|
    \ noremap <buffer> <silent> <SPACE> :call ToggleWinSize(1)<CR>0

    autocmd BufNewFile __Tagbar__
    \ map <unique> <buffer> <silent> <LEADER><ESC> <C-w>p<F5>|
    \ noremap <buffer> <silent> <LEADER><SPACE> :call ToggleWinSize(1)<CR>0

    autocmd BufReadPost quickfix
    \ map <buffer> <silent> <LEADER><ESC> <C-w>p:ccl<CR>|
    \ noremap <buffer> <silent> <SPACE> :call ToggleWinSize(0)<CR>
endif


